import n from"express";import{generateKeyPairSync as t,randomUUID as e}from"node:crypto";import r from"jwt-simple";async function o(n,t){const e=new URLSearchParams;e.append("id_token",t);const r=await fetch(`${n.tokenInfoUrl}?${e.toString()}`);if(r.status>=500)throw new Error("validation internal error");const o=await r.json();if(200!==r.status||o.error)throw new Error(`validation error: ${o.error}`);if(o.aud!==n.clientId)throw new Error("audience mismatch");return o.sub}async function i(n,t){const e=new URLSearchParams;e.append("code",t),e.append("client_id",n.clientId),e.append("client_secret",n.clientSecret);const r=await fetch(n.accessTokenUrl,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:e.toString()}),o=new URLSearchParams(await r.text()),i=o.get("error");if(i)throw new Error(`validation error: ${i}`);const a=o.get("access_token");if(!a)throw new Error("validation internal error");const s=await fetch(n.userUrl,{headers:{Authorization:`Bearer ${a}`}});return(await s.json()).id}async function a(n,t){const e=await fetch(n.tokenInfoUrl,{method:"GET",headers:{Authorization:`Bearer ${t}`}});if(e.status>=500)throw new Error("validation internal error");const r=await e.json();if(200!==e.status||r.error)throw new Error(`validation error: ${r.error}`);if(r.application.uid!==n.clientId)throw new Error("audience mismatch");return r.resource_owner_id}class s{clientConfig={};t=new Map;constructor(n){this.o(n,"google",o),this.o(n,"github",i),this.o(n,"gitlab",a)}supportsService(n){return this.t.has(n)}extractId(n,t){const e=this.t.get(n);if(!e)throw new Error(`Login integration with ${n} is not supported`);return e(t)}o(n,t,e){const r=n[t];r?.clientId&&(this.t.set(t,e.bind(null,r)),this.clientConfig[t]={authUrl:r.authUrl,clientId:r.clientId})}}const c=n.json({limit:4096});function d(t,e){const r=n.Router();return r.get("/",(n,e)=>{e.status(200).json(t.clientConfig)}),r.post("/:name",c,async(n,r,o)=>{const{name:i}=n.params;if(!t.supportsService(i))return void o();const{externalToken:a}=n.body;if(a&&"string"==typeof a)try{const n=await t.extractId(i,a);if(!n)throw new Error("failed to get user ID");const o=e(`${i}-${n}`,i,n);r.status(200).json({userToken:o})}catch(n){n instanceof Error&&"validation internal error"!==n.message?r.status(400).json({error:n.message||"unknown error"}):r.status(500).json({error:"internal error"})}else r.status(400).json({error:"no externalToken provided"})}),r}function u(n){return n&&"string"==typeof n?n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;"):""}function h(){const o=t("rsa",{modulusLength:2048,privateKeyEncoding:{type:"pkcs8",format:"pem"},publicKeyEncoding:{type:"spki",format:"pem"}}),i=n();return i.get("/auth",(n,t)=>{var e;t.header("Content-Type","text/html").send(`\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <title>Mock OAuth service</title>\n    <style>\n      body {\n        background: #EEEEEE;\n        font: 1em sans-serif;\n        margin: 0;\n        padding: 0;\n      }\n      form {\n        width: 400px;\n        max-width: calc(100% - 20px);\n        box-sizing: border-box;\n        margin: 50px auto;\n        padding: 15px;\n        background: #FFFFFF;\n      }\n      h1 {\n        margin: 0 0 20px;\n        text-align: center;\n      }\n      p {\n        font-size: 0.8em;\n        margin: 20px 0;\n      }\n      input[type=text] {\n        width: 200px;\n        font-size: 0.9em;\n        padding: 4px;\n        margin: 0 10px;\n      }\n      button {\n        font-size: 0.9em;\n        padding: 6px 12px;\n        border: none;\n        background: #008800;\n        color: #FFFFFF;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <form method="POST">\n      <h1>Mock OAuth service</h1>\n      <p>\n        This is a mock implementation of an OAuth server for testing purposes.\n      </p>\n      <input type="hidden" name="redirect_uri" value="${u((e=n.query).redirect_uri)}" />\n      <input type="hidden" name="nonce" value="${u(e.nonce)}" />\n      <input type="hidden" name="state" value="${u(e.state)}" />\n      <input type="hidden" name="client_id" value="${u(e.client_id)}" />\n      <label>Sign in as <input type="text" name="identifier" required autofocus /></label><button>Sign in</button>\n    </form>\n  </body>\n</html>\n`)}),i.post("/auth",n.urlencoded({extended:!1}),(n,t)=>{const{redirect_uri:i,nonce:a,state:s,client_id:c,identifier:d}=n.body;i&&c&&d||t.status(400).json({error:"missing fields"});const u=Math.floor(Date.now()/1e3),h=r.encode({aud:c,nonce:a,jti:e(),sub:d,iat:u,exp:u+3600},o.privateKey,"RS256"),p=new URLSearchParams;p.set("id_token",h),p.set("state",s),t.redirect(303,`${i}#${p.toString()}`)}),i.get("/tokeninfo",(n,t)=>{const{id_token:e}=n.query;try{if("string"!=typeof e)throw new Error("Expected string id_token");t.json(r.decode(e,o.publicKey,!1,"RS256"))}catch(n){t.status(400).json({error:"validation failure"})}}),i}function p(n,t){const e=new s(n);return{router:d(e,t),service:e}}export{s as AuthenticationService,p as buildAuthenticationBackend,d as buildAuthenticationRouter,h as buildMockSsoApp};
