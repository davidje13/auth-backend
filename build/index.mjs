import{generateKeyPairSync as n,randomUUID as r}from"node:crypto";import{createServer as t}from"node:http";import{text as e}from"node:stream/consumers";import o from"jwt-simple";async function i(n,r){const t=new URLSearchParams;t.append("id_token",r.externalToken);const e=await fetch(`${n.tokenInfoUrl}?${t.toString()}`);if(e.status>=500)throw new Error("validation internal error");const o=await e.json();if(200!==e.status||o.error)throw new Error(`validation error: ${o.error}`);if(o.aud!==n.clientId)throw new Error("audience mismatch");return o.sub}async function a(n,r){const t=new URLSearchParams;t.append("code",r.externalToken),t.append("client_id",n.clientId),t.append("client_secret",n.clientSecret);const e=await fetch(n.accessTokenUrl,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:t.toString()}),o=new URLSearchParams(await e.text()),i=o.get("error");if(i)throw new Error(`validation error: ${i}`);const a=o.get("access_token");if(!a)throw new Error("validation internal error");const c=await fetch(n.userUrl,{headers:{Authorization:`Bearer ${a}`}});return(await c.json()).id}async function c(n,r){if(!r.redirectUri||!r.codeVerifier)throw new Error("validation error: missing redirect_uri or code_verifier");const t=new URLSearchParams;t.append("grant_type","authorization_code"),t.append("client_id",n.clientId),t.append("code",r.externalToken),t.append("redirect_uri",r.redirectUri),t.append("code_verifier",r.codeVerifier),t.append("code_challenge_method","S256");const e=await fetch(n.accessTokenUrl,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"},body:t.toString()});if(200!==e.status)throw new Error("validation internal error");const o=await e.json();if(!o||"object"!=typeof o)throw new Error("validation internal error");const i=o.error;if(i)throw new Error(`validation error: ${i}`);const a=o.access_token;if(!a)throw new Error("validation internal error");const c=await fetch(n.tokenInfoUrl,{method:"GET",headers:{Authorization:`Bearer ${a}`}});if(c.status>=500)throw new Error("validation internal error");const s=await c.json();if(200!==c.status||s.error)throw new Error(`validation error: ${s.error}`);if(s.application.uid!==n.clientId)throw new Error("audience mismatch");return s.resource_owner_id}class s{clientConfig={};t=new Map;constructor(n){this.o(n,"google",i),this.o(n,"github",a),this.o(n,"gitlab",c)}supportsService(n){return this.t.has(n)}supportedServices(){return[...this.t.keys()]}extractId(n,r){const t=this.t.get(n);if(!t)throw new Error(`Login integration with ${n} is not supported`);return t(r)}o(n,r,t){const e=n[r];e?.clientId&&(this.t.set(r,t.bind(null,e)),this.clientConfig[r]={authUrl:e.authUrl,clientId:e.clientId})}}const d=/^([a-z0-9]+)\/?$/;function u(n,r){const t=(n,r)=>h(r,404,{}),e=e=>n.supportsService(e)?async(t,o)=>{try{const a=await async function(n,r){const t=n.headers["content-length"],e=t?Number.parseInt(t,10):r;if(e>r)throw new Error("too much data");const o=[];let i=0;for await(const r of n){if(i+=r.byteLength,i>e)throw new Error("too much data");o.push(r)}return JSON.parse(Buffer.concat(o,i).toString("utf-8"))}(t,4096);if(null===(i=a)||"object"!=typeof i)throw new Error("missing or invalid body");const{externalToken:c,redirectUri:s,codeVerifier:d}=a;if(!c||"string"!=typeof c)throw new Error("no externalToken");if(void 0!==s&&"string"!=typeof s)throw new Error("invalid redirectUri");if(void 0!==d&&"string"!=typeof d)throw new Error("invalid codeVerifier");const u=await n.extractId(e,{externalToken:c,redirectUri:s,codeVerifier:d});if(!u)throw new Error("failed to get user ID");return h(o,200,{userToken:r(`${e}-${u}`,e,u)})}catch(n){return function(n,r){return r instanceof Error&&"validation internal error"!==r.message?h(n,400,{error:r.message||"unknown error"}):h(n,500,{error:"internal error"})}(o,n)}var i}:t;return(r="")=>(t,o)=>{let i=t.url?.split("?")[0]??"";if(""!==r){if(!i.startsWith(r))return h(o,404,{});i=i.substring(r.length)}if(i.startsWith("/")&&!r.endsWith("/")&&(i=i.substring(1)),"GET"===t.method&&""===i)return((r,t)=>h(t,200,n.clientConfig))(0,o);const[,a]=d.exec(i)??[];return"POST"===t.method&&a?e(a)(t,o):h(o,""===i||a?405:404,{})}}function h(n,r,t){!function(n){n.setHeader("X-Content-Type-Options","nosniff"),n.setHeader("Cache-Control","no-cache, no-store"),n.setHeader("Expires","0"),n.setHeader("Pragma","no-cache")}(n),n.setHeader("Content-Type","application/json; charset=utf-8"),n.writeHead(r),n.write(JSON.stringify(t)),n.end()}function f(n){return n&&"string"==typeof n?n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;"):""}function p(){const i=n("rsa",{modulusLength:2048,privateKeyEncoding:{type:"pkcs8",format:"pem"},publicKeyEncoding:{type:"spki",format:"pem"}});return t(async(n,t)=>{const a=new URL("http://localhost"+n.url),c=new URLSearchParams(a.search);switch(`${n.method} ${a.pathname}`){case"GET /auth":return l(t,200,"text/html; charset=utf-8",(n=>`\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <title>Mock OAuth service</title>\n    <style>\n      body {\n        background: #EEEEEE;\n        font: 1em sans-serif;\n        margin: 0;\n        padding: 0;\n      }\n      form {\n        width: 400px;\n        max-width: calc(100% - 20px);\n        box-sizing: border-box;\n        margin: 50px auto;\n        padding: 15px;\n        background: #FFFFFF;\n      }\n      h1 {\n        margin: 0 0 20px;\n        text-align: center;\n      }\n      p {\n        font-size: 0.8em;\n        margin: 20px 0;\n      }\n      input[type=text] {\n        width: 200px;\n        font-size: 0.9em;\n        padding: 4px;\n        margin: 0 10px;\n        box-sizing: border-box;\n      }\n      button {\n        font-size: 0.9em;\n        padding: 6px 12px;\n        border: none;\n        background: #008800;\n        color: #FFFFFF;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <form method="POST">\n      <h1>Mock OAuth service</h1>\n      <p>\n        This is a mock implementation of an OAuth server for testing purposes.\n      </p>\n      <input type="hidden" name="redirect_uri" value="${f(n.get("redirect_uri"))}" />\n      <input type="hidden" name="nonce" value="${f(n.get("nonce"))}" />\n      <input type="hidden" name="state" value="${f(n.get("state"))}" />\n      <input type="hidden" name="client_id" value="${f(n.get("client_id"))}" />\n      <label>Sign in as <input type="text" name="identifier" required autofocus /></label><button>Sign in</button>\n    </form>\n  </body>\n</html>\n`)(c));case"POST /auth":{const a=new URLSearchParams(await e(n)),c=a.get("redirect_uri"),s=a.get("nonce"),d=a.get("state")??"",u=a.get("client_id"),h=a.get("identifier");if(!c||!u||!h)return w(t,400,{error:"missing fields"});const f=Math.floor(Date.now()/1e3),p=o.encode({aud:u,nonce:s,jti:r(),sub:h,iat:f,exp:f+3600},i.privateKey,"RS256"),l=new URLSearchParams;return l.set("id_token",p),l.set("state",d),function(n,r,t){n.setHeader("Location",t),n.writeHead(r),n.end()}(t,303,`${c}#${l.toString()}`)}case"GET /tokeninfo":{const n=c.get("id_token");try{if("string"!=typeof n)throw new Error("Expected string id_token");return w(t,200,o.decode(n,i.publicKey,!1,"RS256"))}catch(n){return w(t,400,{error:"validation failure"})}}default:t.writeHead(404),t.end()}})}function l(n,r,t,e){n.setHeader("Content-Type",t),n.writeHead(r),n.write(e),n.end()}function w(n,r,t){l(n,r,"application/json; charset=utf-8",JSON.stringify(t))}function m(n,r){const t=new s(n);return{router:u(t,r),service:t}}export{s as AuthenticationService,m as buildAuthenticationBackend,u as buildAuthenticationRouter,p as buildMockSsoApp};
