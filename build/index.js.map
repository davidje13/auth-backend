{"version":3,"sources":["webpack://auth-backend/webpack/universalModuleDefinition","webpack://auth-backend/webpack/bootstrap","webpack://auth-backend/external \"node-fetch\"","webpack://auth-backend/external \"express\"","webpack://auth-backend/./src/providers/GoogleSso.ts","webpack://auth-backend/./src/providers/GitHubSso.ts","webpack://auth-backend/./src/AuthenticationService.ts","webpack://auth-backend/./src/router.ts","webpack://auth-backend/./src/index.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","async","extractId","config","externalToken","params","URLSearchParams","append","res","fetch","tokenInfoUrl","toString","status","Error","externalTokenInfo","json","error","aud","clientId","sub","accessParams","clientSecret","accessRes","accessTokenUrl","method","headers","body","accessResults","text","accessToken","userRes","userUrl","Authorization","id","AuthenticationService","constructor","configs","Map","this","bindExtractor","extractGoogleId","extractGitHubId","supportsService","service","extractors","has","extractor","set","clientConfig","authUrl","JSON_BODY","express","limit","buildAuthenticationRouter","authenticationService","tokenGranter","router","Router","req","post","next","externalId","userToken","e","message","buildAuthenticationBackend"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"auth-backend\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"auth-backend\"] = factory();\n\telse\n\t\troot[\"auth-backend\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"node-fetch\");","module.exports = require(\"express\");","import fetch from 'node-fetch';\n\nexport interface GoogleConfig {\n  clientId: string;\n  authUrl: string;\n  tokenInfoUrl: string;\n}\n\nexport default async function extractId(\n  config: GoogleConfig,\n  externalToken: string,\n): Promise<string> {\n  // These checks can be done locally\n  // see https://developers.google.com/identity/sign-in/web/backend-auth\n\n  const params = new URLSearchParams();\n  params.append('id_token', externalToken);\n  // POST does not work (despite being listed in Google's docs)\n  const res = await fetch(`${config.tokenInfoUrl}?${params.toString()}`);\n\n  if (res.status >= 500) {\n    throw new Error('validation internal error');\n  }\n\n  const externalTokenInfo = await res.json();\n  if (res.status !== 200 || externalTokenInfo.error) {\n    throw new Error(`validation error ${externalTokenInfo.error}`);\n  }\n\n  if (externalTokenInfo.aud !== config.clientId) {\n    throw new Error('audience mismatch');\n  }\n\n  // TODO: use externalTokenInfo.jti nonce to prevent replay attacks\n  // (would need to store value at least until exp time)\n\n  return externalTokenInfo.sub;\n}\n","import fetch from 'node-fetch';\n\nexport interface GitHubConfig {\n  clientId: string;\n  authUrl: string;\n  clientSecret: string;\n  accessTokenUrl: string;\n  userUrl: string;\n}\n\nexport default async function extractId(\n  config: GitHubConfig,\n  externalToken: string,\n): Promise<string> {\n  const accessParams = new URLSearchParams();\n  accessParams.append('code', externalToken);\n  accessParams.append('client_id', config.clientId);\n  accessParams.append('client_secret', config.clientSecret);\n  const accessRes = await fetch(config.accessTokenUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n    body: accessParams.toString(),\n  });\n\n  const accessResults = new URLSearchParams(await accessRes.text());\n\n  const error = accessResults.get('error');\n  if (error) {\n    throw new Error(`validation error ${error}`);\n  }\n\n  const accessToken = accessResults.get('access_token');\n  if (!accessToken) {\n    throw new Error('validation internal error');\n  }\n\n  const userRes = await fetch(config.userUrl, {\n    headers: { Authorization: `Bearer ${accessToken}` },\n  });\n\n  const userResults = await userRes.json();\n  return userResults.id;\n}\n","import extractGoogleId, { GoogleConfig } from './providers/GoogleSso';\nimport extractGitHubId, { GitHubConfig } from './providers/GitHubSso';\n\ntype UnconfiguredExtractor<T> = (config: T, externalToken: string) => Promise<string>;\ntype ConfiguredExtractor = (externalToken: string) => Promise<string>;\n\ninterface ClientProperties {\n  authUrl: string;\n  clientId: string;\n}\n\nexport interface AuthenticationConfiguration {\n  google: GoogleConfig;\n  github: GitHubConfig;\n}\n\nexport type AuthenticationClientConfiguration = Record<string, ClientProperties>;\n\nexport default class AuthenticationService {\n  public readonly clientConfig: AuthenticationClientConfiguration = {};\n\n  private readonly extractors = new Map<string, ConfiguredExtractor>();\n\n  public constructor(configs: Partial<AuthenticationConfiguration>) {\n    this.bindExtractor(configs, 'google', extractGoogleId);\n    this.bindExtractor(configs, 'github', extractGitHubId);\n  }\n\n  public supportsService(service: string): boolean {\n    return this.extractors.has(service);\n  }\n\n  public extractId(\n    service: string,\n    externalToken: string,\n  ): Promise<string> {\n    const extractor = this.extractors.get(service);\n\n    if (!extractor) {\n      throw new Error(`Login integration with ${service} is not supported`);\n    }\n\n    return extractor(externalToken);\n  }\n\n  private bindExtractor<Service extends keyof AuthenticationConfiguration>(\n    configs: Partial<AuthenticationConfiguration>,\n    service: Service,\n    extractor: UnconfiguredExtractor<AuthenticationConfiguration[Service]>,\n  ): void {\n    const config = configs[service];\n    if (config?.clientId) {\n      this.extractors.set(\n        service,\n        extractor.bind(null, config as AuthenticationConfiguration[Service]),\n      );\n      this.clientConfig[service] = {\n        authUrl: config.authUrl,\n        clientId: config.clientId,\n      };\n    }\n  }\n}\n","import express from 'express';\nimport type AuthenticationService from './AuthenticationService';\n\nconst JSON_BODY = express.json({ limit: 4 * 1024 });\n\nexport type TokenGranter = (userId: string, service: string, externalId: string) => string;\n\nexport function buildAuthenticationRouter(\n  authenticationService: AuthenticationService,\n  tokenGranter: TokenGranter,\n): express.Router {\n  const router = express.Router();\n\n  router.get('/', (req, res) => {\n    res.status(200).json(authenticationService.clientConfig);\n  });\n\n  router.post('/:name', JSON_BODY, async (req, res, next) => {\n    const { name } = req.params;\n\n    if (!authenticationService.supportsService(name)) {\n      next();\n      return;\n    }\n\n    const { externalToken } = req.body;\n    if (!externalToken || typeof externalToken !== 'string') {\n      res.status(400).json({ error: 'no externalToken provided' });\n      return;\n    }\n\n    try {\n      const externalId = await authenticationService.extractId(name, externalToken);\n      if (!externalId) {\n        throw new Error('failed to get user ID');\n      }\n\n      const userToken = tokenGranter(`${name}-${externalId}`, name, externalId);\n      res.status(200).json({ userToken });\n    } catch (e) {\n      if (e.message === 'validation internal error') {\n        res.status(500).json({ error: 'internal error' });\n      } else {\n        res.status(400).json({ error: e.message || 'unknown error' });\n      }\n    }\n  });\n\n  return router;\n}\n","import type express from 'express';\nimport AuthenticationService, {\n  AuthenticationConfiguration,\n  AuthenticationClientConfiguration,\n} from './AuthenticationService';\nimport {\n  TokenGranter,\n  buildAuthenticationRouter,\n} from './router';\n\ninterface AuthenticationBackend {\n  router: express.Router;\n  service: AuthenticationService;\n}\n\nexport type {\n  TokenGranter,\n  AuthenticationConfiguration,\n  AuthenticationClientConfiguration,\n};\n\nexport {\n  AuthenticationService,\n  buildAuthenticationRouter,\n};\n\nexport function buildAuthenticationBackend(\n  configs: Partial<AuthenticationConfiguration>,\n  tokenGranter: TokenGranter,\n): AuthenticationBackend {\n  const service = new AuthenticationService(configs);\n  const router = buildAuthenticationRouter(service, tokenGranter);\n\n  return {\n    router,\n    service,\n  };\n}\n"],"sourceRoot":""}